From d6eaeb8b1e20517468d01096220674ce96b8b759 Mon Sep 17 00:00:00 2001
From: Jon Nettleton <jon@solid-run.com>
Date: Wed, 9 Aug 2017 22:55:11 +0200
Subject: [PATCH] sfp: add hpower_level support

This adds the initial bits to support sfp modules that require
a power-level greater than 1.

Signed-off-by: Jon Nettleton <jon@solid-run.com>
---
 arch/arm/boot/dts/armada-388-clearfog.dts  |  1 +
 drivers/net/phy/sfp.c                      | 71 +++++++++++++++++++++++++++---
 2 files changed, 67 insertions(+), 5 deletions(-)

diff --git a/arch/arm/boot/dts/armada-388-clearfog.dts b/arch/arm/boot/dts/armada-388-clearfog.dts
index ffa3957bcd98..89dc9542f120 100644
--- a/arch/arm/boot/dts/armada-388-clearfog.dts
+++ b/arch/arm/boot/dts/armada-388-clearfog.dts
@@ -126,6 +126,7 @@
 		sfp,ethernet = <&eth2>;
 		tx-disable-gpio = <&expander0 14 GPIO_ACTIVE_HIGH>;
 		tx-fault-gpio = <&expander0 13 GPIO_ACTIVE_HIGH>;
+		power-level = <2>;
 	};
 };
 
diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
index b2a1e55c9bb9..557a0f446762 100644
--- a/drivers/net/phy/sfp.c
+++ b/drivers/net/phy/sfp.c
@@ -43,6 +43,7 @@ enum {
 
 	SFP_MOD_EMPTY = 0,
 	SFP_MOD_PROBE,
+	SFP_MOD_HPOWER,
 	SFP_MOD_PRESENT,
 	SFP_MOD_ERROR,
 
@@ -87,6 +88,7 @@ static const enum gpiod_flags gpio_flags[] = {
  * access the I2C EEPROM.  However, Avago modules require 300ms.
  */
 #define T_PROBE_INIT	msecs_to_jiffies(300)
+#define T_HPOWER_LEVEL	msecs_to_jiffies(300)
 #define T_PROBE_RETRY	msecs_to_jiffies(100)
 
 /*
@@ -109,10 +111,12 @@ struct sfp {
 	struct net_device *ndev;
 	struct phylink *phylink;
 	struct phy_device *mod_phy;
+	u8 hpower_level;
 
 	unsigned int (*get_state)(struct sfp *);
 	void (*set_state)(struct sfp *, unsigned int);
 	int (*read)(struct sfp *, bool, u8, void *, size_t);
+	int (*write)(struct sfp *, bool, u8, void *, size_t);
 
 	struct gpio_desc *gpio[GPIO_MAX];
 
@@ -167,8 +171,8 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
 	}
 }
 
-static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
-	void *buf, size_t len)
+static int sfp__i2c_transfer(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+	void *buf, size_t len, bool read)
 {
 	struct i2c_msg msgs[2];
 	int ret;
@@ -178,7 +182,7 @@ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
 	msgs[0].len = 1;
 	msgs[0].buf = &dev_addr;
 	msgs[1].addr = bus_addr;
-	msgs[1].flags = I2C_M_RD;
+	msgs[1].flags = read ? I2C_M_RD : 0;
 	msgs[1].len = len;
 	msgs[1].buf = buf;
 
@@ -192,7 +196,13 @@ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
 static int sfp_i2c_read(struct sfp *sfp, bool a2, u8 addr, void *buf,
 	size_t len)
 {
-	return sfp__i2c_read(sfp->i2c, a2 ? 0x51 : 0x50, addr, buf, len);
+	return sfp__i2c_transfer(sfp->i2c, a2 ? 0x51 : 0x50, addr, buf, len, true);
+}
+
+static int sfp_i2c_write(struct sfp *sfp, bool a2, u8 addr, void *buf,
+	size_t len)
+{
+	return sfp__i2c_transfer(sfp->i2c, a2 ? 0x51 : 0x50, addr, buf, len, false);
 }
 
 static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
@@ -205,6 +215,7 @@ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
 
 	sfp->i2c = i2c;
 	sfp->read = sfp_i2c_read;
+	sfp->write = sfp_i2c_write;
 
 	i2c_mii = mdio_i2c_alloc(sfp->dev, i2c);
 	if (IS_ERR(i2c_mii))
@@ -241,6 +252,11 @@ static int sfp_read(struct sfp *sfp, bool a2, u8 addr, void *buf, size_t len)
 	return sfp->read(sfp, a2, addr, buf, len);
 }
 
+static int sfp_write(struct sfp *sfp, bool a2, u8 addr, void *buf, size_t len)
+{
+	return sfp->write(sfp, a2, addr, buf, len);
+}
+
 static unsigned int sfp_check(void *buf, size_t len)
 {
 	u8 *p, check;
@@ -848,6 +864,32 @@ static int sfp_sm_mod_probe(struct sfp *sfp)
 	return 0;
 }
 
+static int sfp_sm_mod_hpower(struct sfp *sfp)
+{
+	u8 val;
+	int err;
+
+	if (sfp->hpower_level < 2) {
+		if (sfp->id.ext.options & SFP_OPTIONS_POWER_DECL) {
+			dev_err(sfp->dev, "Power level required by the module unsupported\n");
+			return -EINVAL;
+		} else {
+			return 0;
+		}
+	}
+
+	err = sfp_read(sfp, true, 118, &val, sizeof(val));
+	if (err < 0) {
+		dev_err(sfp->dev, "failed to read EEPROM: %d\n", err);
+		return -EAGAIN;
+	}
+
+	val &= BIT(0);
+
+	pr_info("sfp hpower setting extended regs to 0x%x\n", val);
+	return sfp_write(sfp, true, 118, &val, sizeof(val));
+}
+
 static void sfp_sm_mod_remove(struct sfp *sfp)
 {
 	if (sfp->mod_phy)
@@ -885,7 +927,7 @@ static void sfp_sm_event(struct sfp *sfp, unsigned int event)
 			int err = sfp_sm_mod_probe(sfp);
 
 			if (err == 0)
-				sfp_sm_ins_next(sfp, SFP_MOD_PRESENT, 0);
+				sfp_sm_ins_next(sfp, SFP_MOD_HPOWER, 0);
 			else if (err == -EAGAIN)
 				sfp_sm_set_timer(sfp, T_PROBE_RETRY);
 			else
@@ -893,6 +935,22 @@ static void sfp_sm_event(struct sfp *sfp, unsigned int event)
 		}
 		break;
 
+	case SFP_MOD_HPOWER:
+		if (event == SFP_E_REMOVE) {
+			sfp_sm_mod_remove(sfp);
+			sfp_sm_ins_next(sfp, SFP_MOD_EMPTY, 0);
+		} else if (event == SFP_E_TIMEOUT) {
+			int err = sfp_sm_mod_hpower(sfp);
+
+			if (err == 0)
+				sfp_sm_ins_next(sfp, SFP_MOD_PRESENT, 
+				 sfp->id.ext.options & SFP_OPTIONS_POWER_DECL &&
+				 sfp->hpower_level > 1 ? T_HPOWER_LEVEL : 0);
+			else
+				sfp_sm_ins_next(sfp, SFP_MOD_ERROR, 0);
+		}
+		break;
+
 	case SFP_MOD_PRESENT:
 	case SFP_MOD_ERROR:
 		if (event == SFP_E_REMOVE) {
@@ -1244,6 +1302,9 @@ static int sfp_probe(struct platform_device *pdev)
 			return -EPROBE_DEFER;
 		}
 
+		if(of_property_read_u8(node, "power-level", &sfp->hpower_level))
+			sfp->hpower_level = 1;
+
 		phylink_disable(sfp->phylink);
 		phylink_register_module(sfp->phylink, sfp, &sfp_module_ops);
 	}
-- 
2.11.1

